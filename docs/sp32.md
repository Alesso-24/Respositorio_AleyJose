# Documentación de práctica con SP32 y con motores

>  Proyecto académico en donde aplicamos los conocimiento aprendidos en clase, donde controlamos el motor mediante SP32, bajamos y aumentamos su velocidad.

---


## 1) Resumen 
- **Nombre del proyecto:** Control de motores con SP32
- **Equipo / Autor(es):** Alessandro Reyes, Jose Góngora  
- **Curso / Asignatura:** Electrónica / Microcontroladores  
- **Fecha:** 12/09/2025  
- **Descripción breve:** Se realizó la práctica de controles de motores con el microcontrolador SP32, programamos mediante Arduino y documentamos su montaje, su programación y la evidencia.

---


## 2) Objetivos

**General:** Desarrollar habilidades y aprender a cómo funciona un SP32, y como programar motores.


 **Espeficicos** 
 -Encender y apagar motores.
 -Aprender a programar motores.
 -Aprender a usar Arduinos.
 -Aprender a cómo se conectan motores.
 -Documentar y mostrar evidencias.

---


## 3) Alcance y exclusiones

**Incluye:**  
- Montaje de circuítos de motor para conectar con el SP32.
- Programación básica con Arduino IDE.  
- Documentación de código, fotos y video.  
- Programación en arduino como guía básica.  

**No incluye:**  
- Diseño de PCB profesional.  
- Programación avanzada o manejo de interrupciones complejas.  

---

## 4) Requisitos

**Hardware**
- 1 x SP32.
- 1 X MOTOR.
- 1 X CABLE USB- C PARA EL SP32.

**SOFTWARE**
- Aurduino IDE.

**Conocimientos previos**
- Manejo básico de Arduino IDE.  
- Conceptos de entradas y salidas digitales.

---

## 5) Prácticas y Procedimiento 

### **Práctica 1 - ESP32 + MOTOR** 

// Control de motor DC con ESP32 + L298N
// Velocidad por PWM (LEDC) y cambio de giro

// Pines (puedes cambiarlos si lo necesitas)
const int PIN_ENA = 25;   // PWM hacia ENA
const int PIN_IN1 = 26;   // Dirección
const int PIN_IN2 = 27;   // Dirección

// Config PWM ESP32
const int PWM_CH     = 0;       // Canal LEDC
const int PWM_FREQ   = 20000;   // 20 kHz (silencioso)
const int PWM_RES    = 8;       // 8 bits -> 0..255

// (Opcional) potenciómetro para velocidad en pin analógico
// Conecta un pot a 3.3V - GND y el wiper al pin 34
// const int PIN_POT = 34;

void setup() {
  pinMode(PIN_IN1, OUTPUT);
  pinMode(PIN_IN2, OUTPUT);

  // Configurar PWM en ESP32
  ledcSetup(PWM_CH, PWM_FREQ, PWM_RES);
  ledcAttachPin(PPIN_ENA, PWM_CH); // <- corregir a PIN_ENA
  // Ups, typo detectado: usamos la línea correcta
  ledcAttachPin(PIN_ENA, PWM_CH);

  motorStop();
  delay(500);
}

// Funciones básicas
void motorForward(uint8_t speed) { // speed: 0..255
  digitalWrite(PIN_IN1, HIGH);
  digitalWrite(PIN_IN2, LOW);
  ledcWrite(PWM_CH, speed);
}

void motorBackward(uint8_t speed) {
  digitalWrite(PIN_IN1, LOW);
  digitalWrite(PIN_IN2, HIGH);
  ledcWrite(PWM_CH, speed);
}

void motorStop() {
  // Freno suave: desactiva PWM y pone ambas bajas
  ledcWrite(PWM_CH, 0);
  digitalWrite(PIN_IN1, LOW);
  digitalWrite(PIN_IN2, LOW);
}

void loop() {
  // DEMO 1: rampa adelante
  for (int s = 0; s <= 255; s += 5) {
    motorForward(s);
    delay(20);
  }
  delay(500);

  // DEMO 2: rampa atrás
  for (int s = 255; s >= 0; s -= 5) {
    motorBackward(s);
    delay(20);
  }
  delay(500);

  motorStop();
  delay(800);

  // --- DEMO 3 (opcional con potenciómetro) ---
  // Descomenta si conectas un pot en el pin 34
  /*
  int lectura = analogRead(PIN_POT);     // 0..4095
  int vel = map(lectura, 0, 4095, 0, 255);
  motorForward(vel);
  delay(10);
  */
}

