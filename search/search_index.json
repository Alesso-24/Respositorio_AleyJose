{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"Ingenier\u00eda Mecatr\u00f3nica - Documentaci\u00f3n","text":""},{"location":"#jose-manuel-compean-gongora","title":"Jos\u00e9 Manuel Compe\u00e1n G\u00f3ngora","text":"<p>Resumen:  Ingenier\u00eda Mecatr\u00f3nica | 203609@iberopuebla.mx</p> <p></p> <p>Soy Jos\u00e9 Manuel, estudiante de Ingenier\u00eda Mecatr\u00f3nica, apasionado por la tecnolog\u00eda, la programaci\u00f3n y los sistemas electr\u00f3nicos. Aprendo de manera pr\u00e1ctica, aplicando conceptos matem\u00e1ticos y t\u00e9cnicos a situaciones reales. He cursado Electr\u00f3nica Anal\u00f3gica y Sistemas Digitales, y mi enfoque actual est\u00e1 en rob\u00f3tica, donde disfruto integrar sensado, control y actuadores con microcontroladores y l\u00f3gica digital.</p> <p>Me considero una persona cercana, expresiva y curiosa, con gusto por aprender de los dem\u00e1s y mejorar continuamente. Busco equilibrar lo acad\u00e9mico con mi vida diaria, siendo emp\u00e1tico con quienes me rodean y creciendo tambi\u00e9n en lo emocional.</p> <p>El deporte y la actividad f\u00edsica son parte importante de mi vida porque me aportan disciplina y claridad mental. Sobre todo, me motiva seguir aprendiendo electr\u00f3nica: desde el an\u00e1lisis de circuitos y el dise\u00f1o de PCBs hasta la integraci\u00f3n de hardware y software para resolver problemas reales.</p>"},{"location":"#jordi-alessandro-reyes-martinez","title":"Jordi Alessandro Reyes Mart\u00ednez","text":"<p>Ingenier\u00eda Mecatr\u00f3nica | jordi.reyes@iberopuebla.mx</p> <p></p> <p>Resumen: Soy Alessandro Reyes, estudiante de Ingenier\u00eda Mecatr\u00f3nica en la IBERO Puebla, apasionado por la ciencia, la innovaci\u00f3n y los proyectos con impacto social. He desarrollado prototipos enfocados en inclusi\u00f3n y aprendizaje, como Infoc\u00e9lula y LumiBrain, que reflejan mi inter\u00e9s por combinar la tecnolog\u00eda con soluciones que transformen la vida de las personas.</p> <p>Me defino como alguien curioso, creativo y proactivo, con experiencia en liderazgo de proyectos, trabajo comunitario en distintas regiones de M\u00e9xico y participaci\u00f3n en concursos acad\u00e9micos. Mi meta es crecer profesionalmente, vincularme con la industria automotriz en Alemania y dejar una huella positiva en cada reto que enfrento.</p>"},{"location":"555/","title":"\ud83d\udcda Documentaci\u00f3n de la Pr\u00e1ctica \u2013 Temporizador 555 en modo Astable","text":"<p>Proyecto acad\u00e9mico de electr\u00f3nica b\u00e1sica: implementaci\u00f3n de un oscilador astable con el CI 555 para hacer parpadear un LED. Los c\u00e1lculos y simulaciones se realizaron en base a la configuraci\u00f3n est\u00e1ndar del 555.</p>"},{"location":"555/#1-resumen","title":"1) Resumen","text":"<ul> <li>Nombre del proyecto: Oscilador Astable con 555  </li> <li>Equipo / Autor(es): Alessandro Reyes, Jose G\u00f3ngora, Sebasti\u00e1n Cortez  </li> <li>Curso / Asignatura: Electr\u00f3nica / Circuitos Digitales  </li> <li>Fecha: 05/09/2025 </li> <li>Descripci\u00f3n breve: Se dise\u00f1\u00f3 un circuito con el temporizador 555 en modo astable para encender y apagar un LED cada 3\u20135 segundos, armado de forma f\u00edsica y documentado con evidencia en fotos y video.</li> </ul> <p>Consejo</p> <p>Este proyecto sirve como introducci\u00f3n al uso del 555 como generador de se\u00f1ales peri\u00f3dicas.</p>"},{"location":"555/#2-objetivos","title":"2) Objetivos","text":"<p>General: Implementar un circuito oscilador astable con el CI 555 para controlar el parpadeo de un LED.  </p> <p>Espec\u00edficos:   - Dise\u00f1ar el circuito con valores adecuados de resistencias y capacitores.   - Calcular te\u00f3ricamente los tiempos alto y bajo de la se\u00f1al.   - Verificar en la pr\u00e1ctica el correcto parpadeo del LED.   - Comparar resultados te\u00f3ricos y experimentales.  </p>"},{"location":"555/#3-alcance-y-exclusiones","title":"3) Alcance y Exclusiones","text":"<p>Incluye:   - Implementaci\u00f3n en protoboard del 555 en modo astable.   - LED parpadeando con periodo de 3\u20135 segundos.   - Documentaci\u00f3n de c\u00e1lculos y resultados.   - Evidencia en fotos y video.  </p> <p>No incluye:   - Dise\u00f1o de PCB.   - Simulaci\u00f3n en software especializado.   - Implementaci\u00f3n con microcontroladores.  </p>"},{"location":"555/#4-requisitos","title":"4) Requisitos","text":"<p>Hardware - 1 \u00d7 CI 555 - 1 \u00d7 Resistencia R1 = 1 k\u03a9 - 1 \u00d7 Resistencia R2 = 20 k\u03a9 - 1 \u00d7 Capacitor electrol\u00edtico C1 = 330 \u00b5F - 1 \u00d7 LED + resistencia limitadora (330 \u03a9 \u2013 1 k\u03a9) - Fuente de alimentaci\u00f3n (5\u20139 VDC) - Protoboard y cables  </p> <p>Conocimientos previos - Ley de Ohm y c\u00e1lculo de resistencias - Funcionamiento del temporizador 555 - Uso de protoboard y mult\u00edmetro  </p>"},{"location":"555/#5-procedimiento-e-instalacion","title":"5) Procedimiento e Instalaci\u00f3n","text":"<ol> <li>Armar el circuito seg\u00fan el diagrama: </li> </ol> <p>Figura 1. Diagrama del temporizador 555 en modo astable</p> <ol> <li>C\u00e1lculos te\u00f3ricos: </li> </ol> <p>Figura 2. C\u00e1lculos te\u00f3ricos del circuito</p> <ol> <li>Observaci\u00f3n pr\u00e1ctica: El LED permanece encendido ~4.8 s y apagado ~4.6 s, cumpliendo con el requisito (3\u20135 s).</li> </ol>"},{"location":"555/#6-resultados","title":"6) Resultados","text":"<ul> <li>\u2705 LED parpadea dentro del rango esperado (aprox. 9.3 s de periodo total).  </li> <li>\u2705 El comportamiento pr\u00e1ctico coincide con las f\u00f3rmulas.  </li> <li>\u2705 El 555 demostr\u00f3 ser un generador confiable de pulsos de baja frecuencia.</li> </ul> <p>Fotos del montaje f\u00edsico:</p> <p></p> <p>Figura 3. Montaje f\u00edsico \u2013 Vista 1</p> <p></p> <p>Figura 4. Montaje f\u00edsico \u2013 Vista 2</p>"},{"location":"555/#7-video-de-funcionamiento","title":"7) Video de funcionamiento","text":"<p>Figura 3. Video del LED parpadeando</p> <p>\ud83d\udd17 Ver video en OneDrive</p>"},{"location":"esp32_LED/","title":"\ud83d\udcda Documentaci\u00f3n de la Pr\u00e1ctica \u2013 Control de LED con ESP32 (M\u00faltiples Modos)","text":"<p>\ud83e\udde0 Proyecto acad\u00e9mico de introducci\u00f3n a la mecatr\u00f3nica: Implementaci\u00f3n de la placa ESP32 para el control de un LED en tres modos distintos: temporizado, mediante interacci\u00f3n f\u00edsica (bot\u00f3n) y por comunicaci\u00f3n inal\u00e1mbrica (Bluetooth Serial).</p>"},{"location":"esp32_LED/#1-resumen","title":"\ud83e\udded 1) Resumen","text":"Elemento Descripci\u00f3n Nombre del proyecto: LED Multi-Control con ESP32 (Blink, Bot\u00f3n y Bluetooth) Equipo / Autor(es): Alessandro Reyes, Jos\u00e9 Compe\u00e1n Curso / Asignatura: Introducci\u00f3n a la Mecatr\u00f3nica / Programaci\u00f3n de Microcontroladores Fecha: 12 sep 2025 Descripci\u00f3n breve: Se exploraron las funcionalidades b\u00e1sicas de la ESP32 (GPIOs, temporizaci\u00f3n, lectura de entradas y comunicaci\u00f3n inal\u00e1mbrica) implementando tres programas que controlan un LED: parpadeo constante, encendido por pulsaci\u00f3n de bot\u00f3n y control remoto por comandos de texto v\u00eda Bluetooth. <p>\ud83d\udca1 Consejo: Esta pr\u00e1ctica es fundamental para comprender la versatilidad de la ESP32 en la interacci\u00f3n con el entorno (inputs f\u00edsicos) y la comunicaci\u00f3n remota (Bluetooth).</p>"},{"location":"esp32_LED/#2-objetivos","title":"\ud83c\udfaf 2) Objetivos","text":"<p>General: Aplicar los conceptos b\u00e1sicos de programaci\u00f3n de microcontroladores para controlar un actuador (LED) y procesar diferentes tipos de entradas (tiempo, se\u00f1al digital y datos seriales).</p> <p>Espec\u00edficos: - Controlar el tiempo de encendido/apagado del LED usando <code>delay()</code>. - Leer el estado de un bot\u00f3n (entrada digital) y reflejarlo en el LED. - Implementar la comunicaci\u00f3n Bluetooth Serial (SPP). - Procesar los comandos de texto (<code>HIGH</code> / <code>LOW</code>) recibidos por Bluetooth.</p>"},{"location":"esp32_LED/#3-alcance-y-exclusiones","title":"\ud83d\udccb 3) Alcance y Exclusiones","text":"<p>Incluye: - Implementaci\u00f3n de tres programas independientes cargados a la ESP32. - Uso del LED en GPIO 2 y bot\u00f3n en GPIO 4. - Configuraci\u00f3n y prueba de la comunicaci\u00f3n Bluetooth Serial. - C\u00f3digo fuente para las tres etapas.</p> <p>No incluye: - Uso de interrupciones o temporizadores avanzados. - Dise\u00f1o de PCB. - Control basado en Wi-Fi.</p>"},{"location":"esp32_LED/#4-requisitos","title":"\u2699\ufe0f 4) Requisitos","text":""},{"location":"esp32_LED/#hardware","title":"\ud83e\uddf0 Hardware","text":"<ul> <li>1 \u00d7 Placa de desarrollo ESP32 </li> <li>1 \u00d7 LED de cualquier color  </li> <li>1 \u00d7 Resistencia limitadora (220 \u03a9)  </li> <li>1 \u00d7 Bot\u00f3n (pulsador)  </li> <li>1 \u00d7 Resistencia Pull-down (10 k\u03a9)  </li> <li>1 \u00d7 Protoboard y cables  </li> <li>Fuente de alimentaci\u00f3n (5 VDC)  </li> <li>Smartphone con Bluetooth y aplicaci\u00f3n Bluetooth Serial</li> </ul>"},{"location":"esp32_LED/#conocimientos-previos","title":"\ud83d\udcd8 Conocimientos previos","text":"<ul> <li>Programaci\u00f3n en C/C++ (Arduino IDE) </li> <li>Manejo de entradas y salidas digitales (GPIO)  </li> <li>Conceptos b\u00e1sicos de comunicaci\u00f3n serial</li> </ul>"},{"location":"esp32_LED/#5-procedimiento-e-instalacion","title":"\ud83d\udd27 5) Procedimiento e Instalaci\u00f3n","text":"<ol> <li> <p>Montaje del Hardware:    Conectar el LED al GPIO 2 (con su resistencia limitadora) y el Bot\u00f3n al GPIO 4 (con resistencia Pull-down a GND).</p> </li> <li> <p>Carga secuencial de C\u00f3digo:    Cargar cada uno de los tres c\u00f3digos de forma individual a la ESP32 para verificar su funcionamiento.</p> </li> <li> <p>Prueba funcional: </p> </li> <li>Etapa 1: Verificar el parpadeo de 1 s.  </li> <li>Etapa 2: Verificar el encendido solo al presionar el bot\u00f3n.  </li> <li>Etapa 3: Emparejar por Bluetooth y enviar comandos <code>HIGH</code> / <code>LOW</code>.</li> </ol>"},{"location":"esp32_LED/#51-codigo-de-programacion","title":"\ud83d\udcbb 5.1) C\u00f3digo de Programaci\u00f3n","text":""},{"location":"esp32_LED/#etapa-1-led-parpadeante-simple-blink","title":"\ud83d\udd39 Etapa 1 \u2013 LED Parpadeante Simple (Blink) \u23f3","text":"<p>// Definici\u00f3n del pin del LED const int ledPin = 2; // Usamos el GPIO 2</p> <p>void setup() {   pinMode(ledPin, OUTPUT); }</p> <p>void loop() {   // Enciende el LED   digitalWrite(ledPin, HIGH);   delay(1000); // Espera 1 segundo</p> <p>// Apaga el LED   digitalWrite(ledPin, LOW);   delay(1000); // Espera 1 segundo }</p>"},{"location":"esp32_LED/#etapa-2-control-del-led-con-boton","title":"\ud83d\udd39 Etapa 2 \u2013 Control del LED con Bot\u00f3n \ud83d\udd18","text":"<p>El LED se enciende mientras el bot\u00f3n est\u00e1 siendo presionado.</p> <p>// Definici\u00f3n de pines const int ledPin = 2;    // LED en GPIO 2 const int buttonPin = 4; // Bot\u00f3n en GPIO 4</p> <p>void setup() {   pinMode(ledPin, OUTPUT);   // El bot\u00f3n est\u00e1 conectado con una resistencia pull-down externa   pinMode(buttonPin, INPUT);  }</p> <p>void loop() {   // Leer el estado del bot\u00f3n (HIGH al presionar)   int buttonState = digitalRead(buttonPin);</p> <p>// Escribir el estado del bot\u00f3n directamente al LED   digitalWrite(ledPin, buttonState);</p> <p>delay(10); // Anti-rebote simple }</p>"},{"location":"esp32_LED/#etapa-3-control-del-led-por-bluetooth-serial","title":"\ud83d\udd39 Etapa 3 \u2013 Control del LED por Bluetooth Serial \ud83d\udcf2","text":"<p>El LED se controla enviando el texto HIGH o LOW desde una app Bluetooth.</p> <p>BluetoothSerial SerialBT; const int ledPin = 2; String message = \"\"; // Buffer para el comando</p> <p>void setup() {   Serial.begin(115200);   pinMode(ledPin, OUTPUT);</p> <p>SerialBT.begin(\"ESP32_Control_LED\"); // Nombre del dispositivo BT   Serial.println(\"Bluetooth iniciado.\"); }</p> <p>void loop() { if (SerialBT.available()) {     char incomingChar = SerialBT.read();</p> <pre><code>if (incomingChar != '\\n') {\n  message += incomingChar;\n} else {\n  message.trim();\n  message.toUpperCase();\n\n  Serial.print(\"Comando recibido: \");\n  Serial.println(message);\n\n  if (message == \"HIGH\") {\n    digitalWrite(ledPin, HIGH);\n    SerialBT.println(\"\u2705 LED Encendido\");\n  } else if (message == \"LOW\") {\n    digitalWrite(ledPin, LOW);\n    SerialBT.println(\"\u274c LED Apagado\");\n  } else {\n    SerialBT.println(\"\u26a0\ufe0f Comando inv\u00e1lido. Use HIGH o LOW.\");\n  }\n  message = \"\";\n}\n</code></pre> <p>}   delay(20); }</p>"},{"location":"esp32_LED/#6-resultados","title":"\ud83d\udcca 6) Resultados","text":"Etapa Descripci\u00f3n Resultado 1\ufe0f\u20e3 Blink Control temporizado del LED \u2705 Precisi\u00f3n de 2 s por ciclo 2\ufe0f\u20e3 Bot\u00f3n Control f\u00edsico con entrada digital \u2705 Funcionamiento estable 3\ufe0f\u20e3 Bluetooth Control remoto v\u00eda comandos \u2705 Comunicaci\u00f3n correcta <p>\ud83d\udd0d Se demostr\u00f3 la capacidad de la ESP32 para manejar tareas de temporizaci\u00f3n, entradas digitales y comunicaci\u00f3n inal\u00e1mbrica mediante Bluetooth.</p>"},{"location":"esp32_LED/#7-videos-de-funcionamiento","title":"\ud83c\udfa5 7) Videos de Funcionamiento","text":""},{"location":"esp32_LED/#video-1-control-de-led-con-boton","title":"\u25b6\ufe0f Video 1 \u2013 Control de LED con Bot\u00f3n","text":"<p>Video 1. El LED se enciende solo mientras se mantiene presionado el bot\u00f3n.</p> <p>\ud83d\udd17 Ver video</p>"},{"location":"esp32_LED/#video-2-control-de-led-por-bluetooth","title":"\u25b6\ufe0f Video 2 \u2013 Control de LED por Bluetooth","text":"<p>Video 2. Control remoto del LED enviando HIGH/LOW v\u00eda Bluetooth.</p> <p>\ud83d\udd17 Ver video</p>"},{"location":"motores_dc/","title":"\ud83d\udcda Documentaci\u00f3n de la Pr\u00e1ctica \u2013 Control de Motor DC con ESP32 (PWM y Puente H)","text":""},{"location":"motores_dc/#proyecto-academico-de-introduccion-a-la-mecatronica","title":"\ud83e\udde0 Proyecto acad\u00e9mico de introducci\u00f3n a la mecatr\u00f3nica","text":"<p>Implementaci\u00f3n de la placa ESP32 para el control de la direcci\u00f3n y velocidad de un motor DC utilizando el controlador L298N.</p>"},{"location":"motores_dc/#1-resumen","title":"\ud83e\udded 1) Resumen","text":"Elemento Descripci\u00f3n Nombre del proyecto: Control de Motor DC con L298N y ESP32 (Velocidad y Direcci\u00f3n) Equipo / Autor(es): Alessandro Reyes, Jos\u00e9 Compe\u00e1n Curso / Asignatura: Introducci\u00f3n a la Mecatr\u00f3nica / Programaci\u00f3n de Microcontroladores Fecha: 19 sep 2025 Descripci\u00f3n breve: Se exploraron las funcionalidades de la ESP32 para controlar actuadores de mayor potencia. Se implement\u00f3 el m\u00f3dulo L298N para manejar un motor DC, aplicando se\u00f1ales digitales (direcci\u00f3n) y PWM (velocidad) para realizar cambios de sentido y transiciones de aceleraci\u00f3n/desaceleraci\u00f3n. <p>\ud83d\udca1 Consejo: Esta pr\u00e1ctica es crucial para entender el uso de puentes H (como el L298N) para el control de motores y la importancia del PWM para modular la potencia en la mecatr\u00f3nica.</p>"},{"location":"motores_dc/#2-objetivos","title":"\ud83c\udfaf 2) Objetivos","text":""},{"location":"motores_dc/#general","title":"General","text":"<p>Aplicar los conceptos de modulaci\u00f3n por ancho de pulso (PWM) y el manejo de puentes H para lograr un control preciso sobre la velocidad y direcci\u00f3n de un motor DC.</p>"},{"location":"motores_dc/#especificos","title":"Espec\u00edficos","text":"<ul> <li>Configurar y utilizar los pines PWM de la ESP32 (LED Control).  </li> <li>Implementar el control de direcci\u00f3n del motor usando pines digitales.  </li> <li>Conectar y alimentar correctamente el m\u00f3dulo controlador L298N.  </li> <li>Desarrollar un programa que realice una secuencia de aceleraci\u00f3n m\u00e1xima seguida de desaceleraci\u00f3n gradual usando un ciclo <code>for</code>.</li> </ul>"},{"location":"motores_dc/#3-alcance-y-exclusiones","title":"\ud83d\udccb 3) Alcance y Exclusiones","text":"<p>Incluye: - Control de un solo motor DC (Motor A). - Implementaci\u00f3n de tres programas independientes cargados a la ESP32. - Uso de PWM para control de velocidad. - Uso de una fuente de alimentaci\u00f3n externa para el L298N. - Control de la direcci\u00f3n del motor.  </p> <p>No incluye: - Uso de encoders para feedback de velocidad. - Control de motores stepper o servomotores. - Control remoto (Wi-Fi o Bluetooth).  </p>"},{"location":"motores_dc/#4-requisitos","title":"\u2699\ufe0f 4) Requisitos","text":""},{"location":"motores_dc/#hardware","title":"\ud83e\uddf0 Hardware","text":"<ul> <li>1 \u00d7 Placa de desarrollo ESP32 </li> <li>1 \u00d7 M\u00f3dulo controlador de motores L298N (Puente H) </li> <li>1 \u00d7 Motor DC de baja potencia (ej. 5V\u201312V)  </li> <li>1 \u00d7 Fuente de alimentaci\u00f3n externa (ej. bater\u00eda 9V o adaptador 12V)  </li> <li>1 \u00d7 Protoboard y cables  </li> <li>Cables Jumper (al menos 6 M\u2013F)  </li> </ul>"},{"location":"motores_dc/#conocimientos-previos","title":"\ud83d\udcd8 Conocimientos previos","text":"<ul> <li>Programaci\u00f3n en C/C++ (Arduino IDE) </li> <li>Manejo de entradas y salidas digitales (GPIO)  </li> <li>Conceptos de PWM y duty cycle </li> <li>Principios de funcionamiento de un Puente H </li> </ul>"},{"location":"motores_dc/#5-procedimiento-e-instalacion","title":"\ud83d\udd27 5) Procedimiento e Instalaci\u00f3n","text":""},{"location":"motores_dc/#montaje-del-hardware","title":"Montaje del Hardware","text":"<ol> <li>Conectar la ESP32 al lado del motor A del L298N.  </li> <li>Utilizar la fuente externa para la alimentaci\u00f3n del L298N (pin +12V y GND).  </li> </ol>"},{"location":"motores_dc/#cableado","title":"Cableado","text":"<ul> <li>Conectar los pines de direcci\u00f3n (IN1, IN2) a pines digitales de la ESP32 (ej. GPIO 25 y 26).  </li> <li>Conectar el pin de velocidad (ENA) a un pin con capacidad PWM de la ESP32 (ej. GPIO 27).  </li> <li>Conectar el motor a las salidas OUT1/OUT2.  </li> </ul>"},{"location":"motores_dc/#carga-secuencial-de-codigo","title":"Carga secuencial de C\u00f3digo","text":"<p>Cargar cada uno de los tres c\u00f3digos de forma individual para verificar la funcionalidad (direcci\u00f3n, velocidad fija y aceleraci\u00f3n/desaceleraci\u00f3n).</p>"},{"location":"motores_dc/#51-codigo-de-programacion","title":"\ud83d\udcbb 5.1) C\u00f3digo de Programaci\u00f3n","text":""},{"location":"motores_dc/#etapa-1-control-de-direccion-simple-adelante-y-atras","title":"\ud83d\udd39Etapa 1 \u2013 Control de Direcci\u00f3n Simple (Adelante y Atr\u00e1s) \ud83d\udd04","text":"<p>// Pines de control para el Motor const int IN1 = 25; // Direcci\u00f3n 1 const int IN2 = 26; // Direcci\u00f3n 2</p> <p>void setup() {   pinMode(IN1, OUTPUT);   pinMode(IN2, OUTPUT); }</p> <p>void loop() {   // 1. Gira hacia Adelante (HIGH, LOW)   digitalWrite(IN1, HIGH);   digitalWrite(IN2, LOW);   delay(3000);</p> <p>// 2. Detiene el motor (LOW, LOW)   digitalWrite(IN1, LOW);   digitalWrite(IN2, LOW);   delay(1000);</p> <p>// 3. Gira hacia Atr\u00e1s (LOW, HIGH)   digitalWrite(IN1, LOW);   digitalWrite(IN2, HIGH);   delay(3000);</p> <p>// 4. Detiene el motor (LOW, LOW)   digitalWrite(IN1, LOW);   digitalWrite(IN2, LOW);   delay(1000); }</p>"},{"location":"motores_dc/#etapa-2-control-de-velocidad-fija-con-pwm-50","title":"\ud83d\udd39Etapa 2 \u2013 Control de Velocidad Fija con PWM (50%) \u26a1","text":"<p>// Par\u00e1metros PWM de la ESP32 const int freq = 5000;      // Frecuencia PWM (5 kHz) const int ledChannel = 0;   // Canal PWM a usar (0-15) const int resolution = 8;   // Resoluci\u00f3n de 8 bits (0-255) const int dutyCycle = 127;  // 50% de velocidad (127 de 255)</p> <p>// Pines de control const int IN1 = 25; // Direcci\u00f3n 1 const int IN2 = 26; // Direcci\u00f3n 2 const int ENA = 27; // Habilitaci\u00f3n/Velocidad (PWM)</p> <p>void setup() {   pinMode(IN1, OUTPUT);   pinMode(IN2, OUTPUT);</p> <p>ledcSetup(ledChannel, freq, resolution);   ledcAttachPin(ENA, ledChannel); }</p> <p>void loop() {   // 1. Gira Adelante a 50% de velocidad   digitalWrite(IN1, HIGH);   digitalWrite(IN2, LOW);   ledcWrite(ledChannel, dutyCycle);   delay(4000);</p> <p>// Detener el motor   ledcWrite(ledChannel, 0);   delay(1000); }</p>"},{"location":"motores_dc/#etapa-3-secuencia-de-aceleracion-y-desaceleracion-gradual","title":"\ud83d\udd39Etapa 3 \u2013 Secuencia de Aceleraci\u00f3n y Desaceleraci\u00f3n Gradual \u2b06\ufe0f\u2b07\ufe0f","text":"<p>// Pines y par\u00e1metros PWM const int IN1 = 25; const int IN2 = 26; const int ENA = 27; const int ledChannel = 0; const int freq = 5000; const int resolution = 8; // Max dutyCycle = 255</p> <p>void setup() {   pinMode(IN1, OUTPUT);   pinMode(IN2, OUTPUT);   ledcSetup(ledChannel, freq, resolution);   ledcAttachPin(ENA, ledChannel);</p> <p>// Establecer una direcci\u00f3n fija (Adelante)   digitalWrite(IN1, HIGH);   digitalWrite(IN2, LOW); }</p> <p>void loop() {   // 1. Acelera r\u00e1pidamente a velocidad m\u00e1xima (100%)   ledcWrite(ledChannel, 255);   delay(3000);</p> <p>// 2. Desaceleraci\u00f3n gradual (100% a 0)   for (int dutyCycle = 255; dutyCycle &gt;= 0; dutyCycle -= 5) {     ledcWrite(ledChannel, dutyCycle);     delay(50);   }</p> <p>delay(4000); // Motor detenido por 4s antes de repetir }</p>"},{"location":"motores_dc/#6-resultados","title":"\ud83d\udcca 6) Resultados","text":"Etapa Descripci\u00f3n Resultado 1\ufe0f\u20e3 Direcci\u00f3n Control del sentido de giro (adelante/atr\u00e1s) \u2705 Reversibilidad lograda 2\ufe0f\u20e3 Velocidad Fija Control de velocidad con PWM \u2705 Velocidad estable al 50% 3\ufe0f\u20e3 Acel./Desac. Secuencia de m\u00e1xima velocidad seguida de desaceleraci\u00f3n gradual \u2705 Transici\u00f3n de velocidad controlada <p>\ud83d\udd0d Se demostr\u00f3 el control total sobre la potencia (velocidad) y el sentido de giro (direcci\u00f3n) de un motor DC, validando el uso del m\u00f3dulo L298N como interfaz de potencia.</p>"},{"location":"motores_dc/#7-videos-de-funcionamiento","title":"\ud83c\udfa5 7) Videos de Funcionamiento","text":""},{"location":"motores_dc/#video-1-aprendiendo-a-usar-un-motor","title":"\u25b6\ufe0f Video 1 \u2013 Aprendiendo a usar un motor","text":"<p>Video 1. Aprendiendo a usar un motor DC.</p> <p>\ud83d\udd17 Ver video</p>"},{"location":"motores_dc/#video-2-secuencia-de-aceleracion-y-desaceleracion","title":"\u25b6\ufe0f Video 2 \u2013 Secuencia de Aceleraci\u00f3n y Desaceleraci\u00f3n","text":"<p>Video 2. Observaci\u00f3n de la aceleraci\u00f3n a velocidad m\u00e1xima y el frenado progresivo con el ciclo 'for'.</p> <p>\ud83d\udd17 Ver video</p>"},{"location":"plataforma/","title":"\ud83d\udcda Documentaci\u00f3n del Proyecto Final","text":""},{"location":"plataforma/#1-resumen","title":"1) Resumen","text":""},{"location":"plataforma/#nombre-del-proyecto-tabla_balancin","title":"Nombre del proyecto: Tabla_Balancin","text":""},{"location":"plataforma/#equipo-autores-alessandro-reyes-sebastian-cortes-leonardo-llaca","title":"Equipo / Autor(es): Alessandro Reyes, Sebasti\u00e1n Cortes, Leonardo LLaca","text":""},{"location":"plataforma/#curso-asignatura-introduccion-a-la-mecatronica","title":"Curso / Asignatura: Introduccion a la mecatronica","text":""},{"location":"plataforma/#fecha-05dic2025","title":"Fecha: 05/Dic/2025","text":""},{"location":"plataforma/#descripcion-breve-el-proposito-de-este-proyecto-es-lograr-que-una-pelota-se-balancee-sobre-una-superficia-plana-utilizando-herramientas-como-servomotores-programacion-y-modelados-que-priorizen-la-funcionalidad-de-este-proyecto","title":"Descripci\u00f3n breve: El proposito de este proyecto es lograr que una pelota se balancee sobre una superficia plana, utilizando herramientas como servomotores, programacion y modelados que priorizen la funcionalidad de este proyecto.","text":""},{"location":"plataforma/#-","title":"-----------------------------------","text":""},{"location":"plataforma/#2-objetivos","title":"2) Objetivos","text":""},{"location":"plataforma/#general","title":"General:","text":""},{"location":"plataforma/#balancear-una-pelota-de-goma-sobre-una-base","title":"Balancear una pelota de goma sobre una base.","text":""},{"location":"plataforma/#especificos","title":"Espec\u00edficos:","text":""},{"location":"plataforma/#-disenar-la-base-con-los-parametros-adecuados-para-que-en-ningun-momento-se-presenten-problemas-fisicos","title":"- Dise\u00f1ar la base con los parametros adecuados para que en ningun momento se presenten problemas fisicos.","text":""},{"location":"plataforma/#-escribir-un-codigo-en-python-que-cumpla-con-las-especificaciones-necesarias-para-que-pueda-funcionar-el-proposito-principal","title":"- Escribir un codigo en Python que cumpla con las especificaciones necesarias para que pueda funcionar el proposito principal.","text":""},{"location":"plataforma/#-utilizar-herramientas-como-impresion-3d-y-corte-laser-para-generar-eficiencia-en-el-modelado-de-la-base","title":"- Utilizar herramientas como Impresion 3D y Corte laser para generar eficiencia en el modelado de la base.","text":""},{"location":"plataforma/#-medir-probar-y-mejorar-el-rendimiento-de-la-base-para-que-su-funcionamiento-llegue-al-maximo-potencial-posible","title":"- Medir, Probar, y mejorar el rendimiento de la base para que su funcionamiento llegue al maximo potencial posible.","text":""},{"location":"plataforma/#documentacion","title":"Documentaci\u00f3n:","text":""},{"location":"plataforma/#el-proposito-de-la-documentacion-de-este-proyecto-es-poder-dar-instrucciones-claras-para-que-cualquiera-con-los-materiales-y-maquinas-necesarias-pueda-recrear-este-proyecto-a-partir-de-lo-se-ve-en-este-documento","title":"El proposito de la documentacion de este proyecto es poder dar instrucciones claras para que cualquiera con los materiales y maquinas necesarias pueda recrear este proyecto a partir de lo se ve en este documento.","text":""},{"location":"plataforma/#-_1","title":"-----------------------------------","text":""},{"location":"plataforma/#3-alcance-y-exclusiones","title":"3) Alcance y Exclusiones","text":""},{"location":"plataforma/#incluye","title":"Incluye:","text":""},{"location":"plataforma/#-instrucciones-paso-a-paso-para-la-elaboracion-del-proyecto","title":"- Instrucciones paso a paso para la elaboraci\u00f3n del proyecto.","text":""},{"location":"plataforma/#-medidas-de-cada-pieza-utilizada-para-el-ensamblaje-de-la-base-fisica","title":"- medidas de cada pieza utilizada para el ensamblaje de la base fisica.","text":""},{"location":"plataforma/#-codigo-escrito-en-python-para-probar-la-base","title":"- Codigo escrito en Python (Para probar la base).","text":""},{"location":"plataforma/#-codigo-escrito-en-python-finalizado-y-funcional","title":"- Codigo escrito en Python (Finalizado y funcional).","text":""},{"location":"plataforma/#-informacion-completa-acerca-de-materiales-y-programacion","title":"- Informacion completa acerca de materiales y programaci\u00f3n.","text":""},{"location":"plataforma/#-evidencias-en-fisico-y-digital-enfocadas-en-el-proceso","title":"- Evidencias en fisico y digital enfocadas en el proceso.","text":""},{"location":"plataforma/#-_2","title":"-----------------------------------","text":""},{"location":"plataforma/#4-requisitos","title":"4) Requisitos","text":""},{"location":"plataforma/#componentes","title":"Componentes","text":""},{"location":"plataforma/#-1-x-esp-32","title":"- 1 x ESP 32","text":""},{"location":"plataforma/#-3-servomotores-mg996r","title":"- 3 \u00d7 Servomotores MG996R","text":""},{"location":"plataforma/#-1-protoboard","title":"- 1 \u00d7 Protoboard","text":""},{"location":"plataforma/#-fuente-de-alimentacion-6v-2a","title":"- Fuente de alimentaci\u00f3n (6V - 2A)","text":""},{"location":"plataforma/#-jumpers-o-cable","title":"- Jumpers o Cable","text":""},{"location":"plataforma/#material-para-ensamble","title":"Material Para Ensamble","text":""},{"location":"plataforma/#-filamento-pla-para-impresion-3d","title":"- Filamento PLA para impresion 3D.","text":""},{"location":"plataforma/#-mdf-25mm-para-corte-laser","title":"- MDF 2.5mm para corte laser.","text":""},{"location":"plataforma/#-maquina-de-corte-laser","title":"- Maquina de Corte Laser","text":""},{"location":"plataforma/#-impresora-3d","title":"- Impresora 3D","text":""},{"location":"plataforma/#-x9-arandelas","title":"- x9 Arandelas","text":""},{"location":"plataforma/#-x3-tuercas","title":"- x3 Tuercas","text":""},{"location":"plataforma/#programacion","title":"Programaci\u00f3n","text":""},{"location":"plataforma/#-instalar-y-configurar-python-en-su-version-312","title":"- Instalar y Configurar Python (En su versi\u00f3n 3.12 )","text":""},{"location":"plataforma/#-instalar-arduino","title":"- Instalar ARDUINO","text":""},{"location":"plataforma/#-catiav5-para-el-modelado-de-las-piezas","title":"- CATIAV5 (para el modelado de las piezas)","text":""},{"location":"plataforma/#-ultimaker-para-la-impresion-de-las-piezas","title":"- UltiMaker (para la impresion de las piezas)","text":""},{"location":"plataforma/#conocimientos-previos-y-necesarios","title":"Conocimientos previos y necesarios","text":""},{"location":"plataforma/#-conexion-basica-de-los-componentes-mencionados-previamente","title":"- Conexion Basica de los componentes mencionados previamente.","text":""},{"location":"plataforma/#-utilizacion-de-la-fuente-de-alimentacion","title":"- Utilizacion de la Fuente de Alimentaci\u00f3n.","text":""},{"location":"plataforma/#-_3","title":"-----------------------------------","text":""},{"location":"plataforma/#5-procedimiento-paso-a-paso-ensamblaje-fisico","title":"5) Procedimiento Paso a Paso (Ensamblaje Fisico)","text":""},{"location":"plataforma/#51-modelado-e-impresion-y-corte-de-las-piezas-para-ensamble","title":"5.1) Modelado e Impresi\u00f3n y Corte de las piezas para Ensamble","text":""},{"location":"plataforma/#dentro-de-el-siguiente-archivo-se-podran-encontrar-las-piezas-impresas-en-3d-guardadas-como-archivos-de-catia-v5","title":"(\"Dentro de el siguiente archivo se podran encontrar las piezas impresas en 3D guardadas como archivos de CATIA V5\")","text":""},{"location":"plataforma/#httpsdrivegooglecomdrivefolders1urruixqx4pffjv3180pdhcvuy02d2yeruspdrive_link","title":"https://drive.google.com/drive/folders/1URrUiXQX4pFFJv3180PdhCvuy02d2yeR?usp=drive_link","text":""},{"location":"plataforma/#511-soporte-inicial","title":"5.1.1) Soporte Inicial","text":""},{"location":"plataforma/#requisitos-catia-v5-filamento-pla","title":"(Requisitos: CATIA V5, Filamento PLA)","text":""},{"location":"plataforma/#cantidad-x1","title":"(Cantidad: x1)","text":""},{"location":"plataforma/#el-soporte-inicial-es-aquel-en-el-que-se-insertaran-los-3-servomotores-y-donde-se-soporta-todo-el-ensamble","title":"El soporte inicial es aquel en el que se insertaran los 3 servomotores y donde se soporta todo el ensamble.","text":""},{"location":"plataforma/#la-pieza-tiene-como-proposito-sostener-los-servomotores-fijos-a-ella-ante-cualquier-movimiento-que-hagan","title":"la pieza tiene como proposito sostener los servomotores fijos a ella ante cualquier movimiento que hagan","text":""},{"location":"plataforma/#el-soporte-inicial-y-sus-medidas-exactas-se-encuentran-en-el-link-de-drive-bajo-el-mismo-nombre-de-pieza","title":"\"(El Soporte Inicial y sus medidas exactas se encuentran en el link de drive bajo el mismo nombre de pieza.)\"","text":""},{"location":"plataforma/#_1","title":"//////////////////////////////","text":""},{"location":"plataforma/#512-brazo-grueso","title":"5.1.2) Brazo Grueso","text":""},{"location":"plataforma/#requisitos-catia-v5-filamento-pla_1","title":"(Requisitos: CATIA V5, Filamento PLA)","text":""},{"location":"plataforma/#cantidad-x3","title":"(Cantidad: x3)","text":""},{"location":"plataforma/#el-brazo-grueso-es-aquel-que-se-inserta-en-el-centro-de-cada-servo-motor","title":"El brazo Grueso es aquel que se inserta en el centro de cada servo motor.","text":""},{"location":"plataforma/#la-pieza-tiene-como-proposito-ser-parte-del-movimiento-que-balancea-la-pelota-en-la-superficie-final","title":"La pieza tiene como proposito ser parte del movimiento que balancea la pelota en la superficie final.","text":""},{"location":"plataforma/#esta-pieza-estara-conectada-con-otra-similar-a-ella-pero-es-importante-que-no-se-utilize-el-modelo-de-este-brazo-para-el-otro-ya-que-tienen-ciertas-diferencias-que-permiten-que-accionen-correctamente","title":"Esta pieza estara conectada con otra similar a ella, pero es importante que no se utilize el modelo de este brazo para el otro, ya que tienen ciertas diferencias que permiten que accionen correctamente.","text":""},{"location":"plataforma/#el-brazo-grueso-y-sus-medidas-exactas-se-encuentran-en-el-link-de-drive-bajo-el-mismo-nombre-de-pieza","title":"\"(El Brazo Grueso y sus medidas exactas se encuentran en el link de drive bajo el mismo nombre de pieza.)\"","text":""},{"location":"plataforma/#medidas","title":"(\"Medidas\")","text":""},{"location":"plataforma/#ancho-7mm","title":"(Ancho: 7mm  )","text":""},{"location":"plataforma/#alto-150mm","title":"(Alto: 150mm )","text":""},{"location":"plataforma/#_2","title":"//////////////////////////////","text":""},{"location":"plataforma/#513-brazo-delgado","title":"5.1.3) Brazo Delgado","text":""},{"location":"plataforma/#requisitos-catia-v5-filamento-pla_2","title":"(Requisitos: CATIA V5, Filamento PLA)","text":""},{"location":"plataforma/#cantidad-x3_1","title":"(Cantidad: x3)","text":""},{"location":"plataforma/#el-brazo-delgado-es-aquel-que-se-junta-con-el-brazo-grueso-a-partir-del-agujero-superior","title":"El brazo Delgado es aquel que se junta con el brazo grueso a partir del agujero superior.","text":""},{"location":"plataforma/#la-pieza-tiene-como-proposito-insertarse-en-los-cilindros-conectados-a-la-base-plana","title":"La pieza tiene como proposito insertarse en los cilindros conectados a la base plana.","text":""},{"location":"plataforma/#con-esta-pieza-se-logra-conectar-el-movimiento-de-los-servomotores-con-la-base-plana-permitiendo-que-el-balanceo-sea-posible","title":"Con esta pieza se logra conectar el movimiento de los servomotores con la base plana, permitiendo que el balanceo sea posible.","text":""},{"location":"plataforma/#el-cilindro-y-sus-medidas-exactas-se-encuentran-en-el-link-de-drive-bajo-el-mismo-nombre-de-pieza","title":"\"(El Cilindro y sus medidas exactas se encuentran en el link de drive bajo el mismo nombre de pieza.)\"","text":""},{"location":"plataforma/#medidas_1","title":"(\"Medidas\")","text":""},{"location":"plataforma/#ancho-7mm_1","title":"(Ancho: 7mm  )","text":""},{"location":"plataforma/#alto-150mm_1","title":"(Alto: 150mm )","text":""},{"location":"plataforma/#_3","title":"//////////////////////////////","text":""},{"location":"plataforma/#514-cilindro","title":"5.1.4) Cilindro","text":""},{"location":"plataforma/#requisitos-catia-v5-filamento-pla_3","title":"(Requisitos: CATIA V5, Filamento PLA)","text":""},{"location":"plataforma/#cantidad-x3_2","title":"(Cantidad: x3)","text":""},{"location":"plataforma/#el-cilindro-es-aquella-pieza-que-va-pegada-a-la-base-plana-y-donde-se-inserta-el-brazo-delgado","title":"El cilindro es aquella pieza que va pegada a la base plana y donde se inserta el brazo delgado","text":""},{"location":"plataforma/#la-pieza-tiene-como-proposito-permitir-que-todas-las-piezas-esten-conectadas-entre-si-e-interactuen-para-generar-el-proposito-del-proyecto","title":"La pieza tiene como proposito permitir que todas las piezas esten conectadas entre si e interactuen para generar el proposito del proyecto.","text":""},{"location":"plataforma/#esta-pieza-nos-permite-encajar-el-movimiento-de-nuestros-brazos-a-una-superficie-habilitando-el-objetivo-principal","title":"Esta pieza nos permite encajar el movimiento de nuestros brazos a una superficie, habilitando el objetivo principal","text":""},{"location":"plataforma/#el-cilindro-y-sus-medidas-exactas-se-encuentran-en-el-link-de-drive-bajo-el-mismo-nombre-de-pieza_1","title":"\"(El Cilindro y sus medidas exactas se encuentran en el link de drive bajo el mismo nombre de pieza.)\"","text":""},{"location":"plataforma/#_4","title":"//////////////////////////////","text":""},{"location":"plataforma/#515-base-plana","title":"5.1.5) Base Plana","text":""},{"location":"plataforma/#requisitos-mdf-25-mm","title":"(Requisitos: MDF 2.5 mm )","text":""},{"location":"plataforma/#cantidad-x1_1","title":"(Cantidad: x1)","text":""},{"location":"plataforma/#la-base-plana-es-aquella-pieza-que-permite-que-el-balanceo-de-la-pelota-sea-posible-finalizando-la-ultima-parte-del-ensamble","title":"La base plana es aquella pieza que permite que el balanceo de la pelota sea posible, finalizando la ultima parte del ensamble","text":""},{"location":"plataforma/#la-pieza-tiene-como-proposito-coincidir-con-los-movimientos-emitidos-por-los-brazos","title":"La pieza tiene como proposito coincidir con los movimientos emitidos por los brazos.","text":""},{"location":"plataforma/#esta-pieza-nos-permite-encajar-el-movimiento-de-nuestros-brazos-a-una-superficie-habilitando-el-objetivo-principal_1","title":"Esta pieza nos permite encajar el movimiento de nuestros brazos a una superficie, habilitando el objetivo principal","text":""},{"location":"plataforma/#medidas_2","title":"(\"Medidas\")","text":""},{"location":"plataforma/#ancho-220mm","title":"(Ancho: 220mm )","text":""},{"location":"plataforma/#alto-220mm","title":"(Alto:  220mm )","text":""},{"location":"plataforma/#52-ensamblaje-de-las-piezas","title":"5.2) Ensamblaje de las piezas","text":""},{"location":"plataforma/#una-vez-cortadas-e-impresas-las-piezas-es-momento-de-ensamblar","title":"Una vez cortadas e impresas las piezas, es momento de ensamblar","text":""},{"location":"plataforma/#primera-ilustracion-de-guia-para-ensamblaje","title":"(primera ilustracion de guia para ensamblaje)","text":""},{"location":"plataforma/#1-como-se-puede-observar-en-la-imagen-cada-uno-de-los-servomotores-deben-ser-insertados-en-la-base-plana-es-importante-que-todos-queden-ajustados-a-presion-y-en-caso-de-que-tengan-complicaciones-es-recomendable-insertar-pijas-para-mantenerlo-fijo","title":"1. Como se puede observar en la imagen, cada uno de los servomotores deben ser insertados en la base plana, es importante que todos queden ajustados a presion, y en caso de que tengan complicaciones, es recomendable insertar pijas para mantenerlo fijo.","text":""},{"location":"plataforma/#2-posteriormente-a-esto-el-brazo-grueso-de-igual-manera-debe-ser-insertado-a-presion-en-el-servomotor-hasta-que-ambas-piezas-se-muevan-simultaneamente-de-igual-manera-es-posible-utilizar-tornillos-si-llega-a-haber-movimiento-inesperado","title":"2. Posteriormente a esto, el brazo grueso de igual manera debe ser insertado a presion en el servomotor, hasta que ambas piezas se muevan simultaneamente, de igual manera es posible utilizar tornillos si llega a haber movimiento inesperado","text":""},{"location":"plataforma/#segunda-ilustracion-de-guia-para-ensamblaje","title":"(Segunda Ilustracion de guia para ensamblaje)","text":""},{"location":"plataforma/#3-una-vez-colocado-el-brazo-grueso-colocar-el-brazo-delgado-paralelo-a-la-pieza-y-utilizando-3-arandelas-colocarlas-entre-los-brazos-para-posteriormente-insertar-una-tornillo-y-fijarlo-con-una-tuerca-para-que-no-haya-inestabilidad-en-el-movimiento-de-los-brazos","title":"3. Una vez colocado el brazo grueso, colocar el Brazo delgado Paralelo a la pieza, y utilizando 3 arandelas, colocarlas entre los brazos, para posteriormente insertar una tornillo y fijarlo con una tuerca para que no haya inestabilidad en el movimiento de los brazos.","text":""},{"location":"plataforma/#tercera-ilustracion-de-guia-para-ensamblaje","title":"(Tercera Ilustracion de guia para ensamblaje)","text":""},{"location":"plataforma/#4-finalmente-inserta-el-cilindro-en-la-parte-superior-de-el-brazo-delgado-y-asegurate-de-que-esta-pieza-vaya-pegada-a-tu-base-plana","title":"4. Finalmente, inserta el cilindro en la parte superior de el brazo delgado, y asegurate de que esta pieza vaya pegada a tu base plana","text":""},{"location":"plataforma/#-_4","title":"-----------------------------------","text":""},{"location":"plataforma/#6-procedimiento-paso-a-paso-conexion-electronica-y-programacion","title":"6) Procedimiento Paso a Paso (Conexion Electronica y Programaci\u00f3n)","text":""},{"location":"plataforma/#una-vez-todos-los-requisitos-se-cumplan-proceder-a-esta-seccion-de-la-guia-para-programar-y-conectar-el-circuito-completo","title":"(Una vez todos los requisitos se cumplan, proceder a esta seccion de la guia para Programar y Conectar el circuito completo)","text":""},{"location":"plataforma/#ya-con-python-instalado-conecta-tu-esp32-con-la-placa-de-expansion-junto-con-los-3-servo-motores-conectados-a-la-esp-para-senal","title":"Ya con python instalado, Conecta tu ESP32 con la placa de expansion, junto con los 3 servo motores conectados a la esp para se\u00f1al","text":""},{"location":"plataforma/#todo-esto-conectado-a-una-fuente-externa-a-6v-2a","title":"(Todo esto conectado a una fuente externa a 6V - 2A)","text":""},{"location":"plataforma/#ya-vinculada-tu-esp32-a-tu-computadora-ejecuta-primero-el-siguiente-codigo-en-arduino","title":"Ya vinculada tu ESP32 a tu computadora, ejecuta primero el siguiente codigo en ARDUINO","text":"<pre><code>#include \"BluetoothSerial.h\"\n\nBluetoothSerial SerialBT;\nString device_name = \"ESP32_PROYECTO_FINAL\";\n\n// --- PINES ---\nconst int PIN_S1 = 18; // Amarillo (Izq)\nconst int PIN_S2 = 19; // Verde (Abajo)\nconst int PIN_S3 = 21; // Rojo (Der)\n\n// --- CONFIGURACI\u00d3N ---\nconst int ANG_BASE = 50;  \nconst int ANG_MIN  = 50;  \nconst int ANG_MAX  = 110;  \n\n// --- PID ---\nfloat kp = 0.15;  \nfloat ki = 0.0;\nfloat kd = 0.40;\n\nfloat lastErrorX = 0, cumErrorX = 0;\nfloat lastErrorY = 0, cumErrorY = 0;\nfloat angS1 = ANG_BASE, angS2 = ANG_BASE, angS3 = ANG_BASE;\n\nvoid moverServo(int pin, int angulo) {\n  if (angulo &lt; ANG_MIN) angulo = ANG_MIN;\n  if (angulo &gt; ANG_MAX) angulo = ANG_MAX;\n  int pulso = 500 + ((long)angulo * 1900) / 180;\n  digitalWrite(pin, HIGH);\n  delayMicroseconds(pulso);\n  digitalWrite(pin, LOW);\n}\n\nvoid setup() {\n  Serial.begin(115200);\n  SerialBT.begin(device_name);\n  Serial.println(\"BLUETOOTH LISTO. EJE X CORREGIDO\");\n\n  pinMode(PIN_S1, OUTPUT); pinMode(PIN_S2, OUTPUT); pinMode(PIN_S3, OUTPUT);\n\n  // Saludo\n  moverServo(PIN_S2, 80); delay(400);\n  moverServo(PIN_S2, ANG_BASE);\n}\n\nvoid loop() {\n  // Refresco constante\n  moverServo(PIN_S1, (int)angS1);\n  moverServo(PIN_S2, (int)angS2);\n  moverServo(PIN_S3, (int)angS3);\n  delay(15);\n\n  if (SerialBT.available()) {\n    String packet = SerialBT.readStringUntil('\\n');\n    float inX, inY, inP, inI, inD;\n    int n = sscanf(packet.c_str(), \"%f,%f,%f,%f,%f\", &amp;inX, &amp;inY, &amp;inP, &amp;inI, &amp;inD);\n\n    if (n == 5) {\n      kp = inP; ki = inI; kd = inD;\n\n      // PID X\n      float errorX = inX;\n      cumErrorX = constrain(cumErrorX + errorX, -200, 200);\n      float outputX = (errorX * kp) + (cumErrorX * ki) + ((errorX - lastErrorX) * kd);\n      lastErrorX = errorX;\n\n      // PID Y\n      float errorY = inY;\n      cumErrorY = constrain(cumErrorY + errorY, -200, 200);\n      float outputY = (errorY * kp) + (cumErrorY * ki) + ((errorY - lastErrorY) * kd);\n      lastErrorY = errorY;\n\n      // === CINEM\u00c1TICA CORREGIDA ===\n\n      // S2 (Abajo): Pitch puro.\n      float targetS2 = ANG_BASE + (outputY * 1.0);\n\n      // AQU\u00cd ESTABA EL ERROR: He invertido los signos de outputX.\n      // Antes S1 ten\u00eda \"+ outputX\", ahora tiene \"- outputX\".\n      // Antes S3 ten\u00eda \"- outputX\", ahora tiene \"+ outputX\".\n      float targetS1 = ANG_BASE + (-outputY * 0.5) - outputX;\n      float targetS3 = ANG_BASE + (-outputY * 0.5) + outputX;\n\n      angS1 = constrain(targetS1, ANG_MIN, ANG_MAX);\n      angS2 = constrain(targetS2, ANG_MIN, ANG_MAX);\n      angS3 = constrain(targetS3, ANG_MIN, ANG_MAX);\n    }\n  }\n}\n</code></pre>"},{"location":"plataforma/#el-siguiente-codigo-es-el-que-se-ejecuta-para-ajustar-el-pid-de-la-base","title":"El siguiente codigo es el que se ejecuta para ajustar el PID de la base","text":""},{"location":"plataforma/#los-valores-ya-estan-predeterminados-y-deberan-ser-dejados-asi-para-este-caso-especifico","title":"Los valores ya estan predeterminados y deberan ser dejados asi para este caso especifico.","text":""},{"location":"plataforma/#a-continuacion-el-codigo-final-en-python","title":"A continuacion el codigo final en Python.","text":"<pre><code>import cv2\nimport numpy as np\nimport serial\nimport time\nimport math\n\n# --- CONFIGURACI\u00d3N ---\nPUERTO = 'COM19'  \nBAUD   = 115200\n\n# Conexi\u00f3n\nser = None\ntry:\n    ser = serial.Serial(PUERTO, BAUD, timeout=0.1, write_timeout=0)\n    print(f\"CONECTADO A {PUERTO}\")\n    time.sleep(2)\nexcept Exception as e:\n    print(f\"Error Bluetooth: {e}\")\n\n# C\u00c1MARA (\u00cdndice 1)\ncap = cv2.VideoCapture(2, cv2.CAP_DSHOW)\n\n# --- RANGOS PELOTA ---\nrojo_bajo1 = np.array([0, 120, 70]); rojo_alto1 = np.array([10, 255, 255])\nrojo_bajo2 = np.array([170, 120, 70]); rojo_alto2 = np.array([180, 255, 255])\n\n# --- VARIABLES ---\nlast_send_time = 0\nSEND_INTERVAL = 0.08\nprev_ball_center = None\n\n# Variables de \"Memoria\" para la base\nlast_plate_center = None\nframes_lost = 0 # Contador de cuadros perdidos\n\ndef nothing(x): pass\n\n# --- VENTANA AJUSTES ---\ncv2.namedWindow(\"AJUSTES\")\ncv2.resizeWindow(\"AJUSTES\", 400, 400)\n\ncv2.createTrackbar(\"Kp (x100)\", \"AJUSTES\", 22, 300, nothing)\ncv2.createTrackbar(\"Kd BASE (x100)\", \"AJUSTES\", 45, 300, nothing)\ncv2.createTrackbar(\"Turbo Freno\", \"AJUSTES\", 15, 50, nothing)\n\n# VISI\u00d3N: Empezamos con un valor alto para aceptar grises\ncv2.createTrackbar(\"Umbral Negro\", \"AJUSTES\", 100, 255, nothing)\n\nprint(\"SISTEMA LISTO. 'q' para salir.\")\n\nwhile True:\n    ret, frame = cap.read()\n    if not ret: break\n    frame = cv2.resize(frame, (640, 480))\n\n    # Leer Sliders\n    base_kp = cv2.getTrackbarPos(\"Kp (x100)\", \"AJUSTES\") / 100.0\n    base_kd = cv2.getTrackbarPos(\"Kd BASE (x100)\", \"AJUSTES\") / 100.0\n    turbo   = cv2.getTrackbarPos(\"Turbo Freno\", \"AJUSTES\") / 10.0\n    thresh  = cv2.getTrackbarPos(\"Umbral Negro\", \"AJUSTES\")\n\n    # ==========================================\n    # 1. DETECCI\u00d3N DE BASE (ESTRATEGIA \"MANCHA GIGANTE\")\n    # ==========================================\n    gray = cv2.cvtColor(frame, cv2.COLOR_BGR2GRAY)\n    blurred = cv2.GaussianBlur(gray, (5, 5), 0) # Poco blur para no perder bordes\n\n    # Umbral Invertido (Negro -&gt; Blanco)\n    _, mask_plate = cv2.threshold(blurred, thresh, 255, cv2.THRESH_BINARY_INV)\n\n    # Rellenar agujeros (Reflejos)\n    kernel = cv2.getStructuringElement(cv2.MORPH_RECT, (25, 25))\n    mask_plate = cv2.morphologyEx(mask_plate, cv2.MORPH_CLOSE, kernel)\n\n    # Limpiar ruido peque\u00f1o\n    mask_plate = cv2.erode(mask_plate, None, iterations=2)\n    mask_plate = cv2.dilate(mask_plate, None, iterations=2)\n\n    cnts_plate, _ = cv2.findContours(mask_plate, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE)\n\n    current_plate_center = None\n\n    if len(cnts_plate) &gt; 0:\n        # Tomamos SOLO el objeto m\u00e1s grande. No importa si es cuadrado o amorfo.\n        c_plate = max(cnts_plate, key=cv2.contourArea)\n\n        # Si es suficientemente grande, lo aceptamos como base\n        if cv2.contourArea(c_plate) &gt; 20000:\n            M = cv2.moments(c_plate)\n            if M[\"m00\"] != 0:\n                current_plate_center = (int(M[\"m10\"] / M[\"m00\"]), int(M[\"m01\"] / M[\"m00\"]))\n\n                # Dibujamos lo que detectamos\n                rect = cv2.minAreaRect(c_plate)\n                box = np.int64(cv2.boxPoints(rect))\n                cv2.drawContours(frame, [box], 0, (0, 255, 0), 2)\n                cv2.circle(frame, current_plate_center, 5, (0, 255, 0), -1)\n\n                # Actualizamos la memoria\n                last_plate_center = current_plate_center\n                frames_lost = 0\n\n    # SISTEMA DE MEMORIA (ANTI-PARPADEO)\n    if current_plate_center is None:\n        frames_lost += 1\n        # Si perdimos la base por menos de 10 cuadros (0.3 seg), usamos la \u00faltima posici\u00f3n\n        if last_plate_center is not None and frames_lost &lt; 10:\n            current_plate_center = last_plate_center\n            cv2.putText(frame, \"MEMORIA ACTIVA\", (10, 450), cv2.FONT_HERSHEY_SIMPLEX, 0.7, (0, 165, 255), 2)\n        else:\n            cv2.putText(frame, \"BASE PERDIDA\", (10, 450), cv2.FONT_HERSHEY_SIMPLEX, 0.7, (0, 0, 255), 2)\n\n    # ==========================================\n    # 2. PELOTA Y CONTROL\n    # ==========================================\n    if current_plate_center is not None:\n        hsv = cv2.cvtColor(frame, cv2.COLOR_BGR2HSV)\n        mask_ball = cv2.add(cv2.inRange(hsv, rojo_bajo1, rojo_alto1), cv2.inRange(hsv, rojo_bajo2, rojo_alto2))\n        mask_ball = cv2.erode(mask_ball, None, iterations=2)\n        mask_ball = cv2.dilate(mask_ball, None, iterations=2)\n\n        cnts_ball, _ = cv2.findContours(mask_ball, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE)\n\n        if len(cnts_ball) &gt; 0:\n            c_ball = max(cnts_ball, key=cv2.contourArea)\n            ((x, y), radio) = cv2.minEnclosingCircle(c_ball)\n\n            if radio &gt; 8:\n                ball_center = (int(x), int(y))\n\n                # Velocidad\n                velocity = 0\n                if prev_ball_center is not None:\n                    dx = ball_center[0] - prev_ball_center[0]\n                    dy = ball_center[1] - prev_ball_center[1]\n                    velocity = math.sqrt(dx*dx + dy*dy)\n                prev_ball_center = ball_center\n\n                # Turbo\n                final_kd = base_kd + (velocity * turbo / 10.0)\n\n                # Visualizaci\u00f3n\n                cv2.circle(frame, ball_center, int(radio), (0, 255, 255), 2)\n                cv2.line(frame, current_plate_center, ball_center, (0, 255, 0), 2)\n\n                # Error (Usando el centro actual o memorizado)\n                error_x_raw = x - current_plate_center[0]\n                error_y_raw = y - current_plate_center[1]\n\n                val_x = int(np.interp(error_x_raw, [-200, 200], [-50, 50]))\n                val_y = int(np.interp(error_y_raw, [-200, 200], [-50, 50]))\n\n                # Env\u00edo\n                if ser and ser.is_open and (time.time() - last_send_time &gt; SEND_INTERVAL):\n                    try:\n                        msg = f\"{val_x},{val_y},{base_kp:.2f},{0:.2f},{final_kd:.2f}\\n\"\n                        ser.write(msg.encode())\n                        last_send_time = time.time()\n\n                        cv2.putText(frame, f\"TX: {val_x},{val_y}\", (10, 30),\n                                    cv2.FONT_HERSHEY_SIMPLEX, 0.6, (0, 255, 0), 2)\n                    except: pass\n        else:\n            prev_ball_center = None\n\n    # Muestra la m\u00e1scara para que calibres\n    cv2.imshow(\"Mascara Base (Blanco=OK)\", mask_plate)\n    cv2.imshow(\"Vision Control\", frame)\n\n    if cv2.waitKey(1) &amp; 0xFF == ord('q'): break\n\ncap.release()\ncv2.destroyAllWindows()\nif ser: ser.close()\n</code></pre>"},{"location":"plataforma/#ambos-codigos-permiten-el-funcionamiento-del-balancin-con-la-condicion-de-que-todos-los-pasos-del-ensamblaje-y-la-parametrizacion-de-las-impresiones-haya-sido-la-correcta","title":"Ambos codigos permiten el funcionamiento del Balancin con la condicion de que todos los pasos del ensamblaje y la parametrizacion de las impresiones haya sido la correcta.","text":""},{"location":"plataforma/#-_5","title":"-----------------------------------","text":""},{"location":"plataforma/#7-resultados-y-evidencias-finales","title":"7) Resultados y Evidencias Finales","text":""},{"location":"plataforma/#si-todos-los-pasos-se-siguieron-de-la-manera-correcta-el-resultado-final-deberia-ser-exacto-o-muy-similar-al-del-siguiente-video","title":"Si todos los pasos se siguieron de la manera correcta, el resultado final deberia ser exacto o muy similar al del siguiente video.","text":""},{"location":"plataforma/#evidencia","title":"EVIDENCIA","text":"<p>Ver video de demostraci\u00f3n</p>"}]}